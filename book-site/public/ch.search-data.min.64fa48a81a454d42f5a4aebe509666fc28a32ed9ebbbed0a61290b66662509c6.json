[{"id":0,"href":"/notes/docs/cs/c-progaming-language/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0/","title":"可变参数跨的平台","section":"C programing Language","content":"111\n0.问题引入 # 在做一生一芯的过程中，需要用到 abstract-machine ，其中需要实现可以跨平台的 vspinrtf ，这需要用到头文件 \u0026lt;stdarg.h\u0026gt;， 以及声明在这里面的一些宏以及函数。可以通过 man 3 va_start 查看他们的手册。\n我的实现大概如下：\nstaitc int handle_fmt(char ** pout, char ** pp_fmt, va_list sp) { ... switch(**pp_fmt) { case \u0026#39;s\u0026#39;: ... case \u0026#39;d\u0026#39;: ... int num = va_arg(sp, int); ... } ... } int vsprintf(char *out, const char *fmt, va_list ap) { ... handle_fmt(\u0026amp;out, \u0026amp;p_fmt, ap); ... } int sprintf(char *out, const char *fmt, ...) { va_list vlist; va_start(vlist, fmt); int r = vsprintf(out, fmt,vlist); va_end(vlist); } 对于上面这种实现，在x86 linux环境下可以正常运行，而在riscv32-nemu 和 riscv32 linux环境下，sprintf(buf, \u0026quot;%d %d\u0026quot;, 1, 3); 会将 \u0026quot;1 1\u0026quot; 复制到 buf。并且：\n在 x86-linux 可以通过各种测试用例，而在 riscv32-nemu 无法通过； riscv32-nemu 与 spike 进行差分测试无报错。 对于编译linux x86 架构程序，可以通过给 x86_64-linux-gnu-gcc 传递 -m32 和 -m64 (System V AMD64 ABI) 选择相应的 ABI， 而对于 riscv ，则可以传递 -mabi=ilp32/lp64/... 来选择程序遵循的 ABI；此外，都可以通过 -march 来选择支持的扩展指令集。例如，-march=rv64im 表明支持乘法扩展的 64 位指令集。\n1. 阅读手册 # 阅读 C99 标准手册 7.15 Variable arguments 部分，发现上述宏都是 implementation-defined 的， 因此可以查询相应的 ABI 手册。\n##1.1 RISC-V ABI 对可变参数传参的描述\n这里只是对ABI手册做一个个简单的概述，具体可参考 RISCV ABI .\n可变参数优先通过寄存器传递： 该参数对齐到 2 × XLEN 且该参数大小最大为 2 × XLEN (例如，XLEN = 32， 那么1，2，4，8字节的可变参数都可以这种方式传递)，此时还需要找到一个寄存器 $a_i$ ，其中 $i$ 为偶数， 在 $a_i$​ 和 $a_{i+1} 中存放这个参数。 遇到第一个需要放到栈上的可变参数后，后面的可变参数都需要放到栈上。 va_list 类型上是一个 void * 。 无论可变参数是否通过栈传递，最终都要放到栈上，并且由一个 va_list 类型的指针指向其第一个可变参数。 va_arg 取出一个可变参数，然后自增 va_list . 1.2 System V AMD64 ABI # 首先引入一个 System V AMD64 ABI 对函数传递的参数分类中的一个类型, INTEGER 类型 : This class consists of integral types that fit into one of the general purpose registers.\n阅读 System V AMD64 ABI 手册 3.5.7 Variable Argument Lists , 重点关注该类型的参数在可变的情况下是如何传递的：\n依旧优先使用 %RDI, %RSI, %RDX, %RCX, %R8, %R9 来传递，这 6 个寄存器用完了再放在栈上(这里和普通参数规则一样)；\n在确定函数具有可变参数列表且调用 va_start 的情况下，一定会在这个函数 prolgue 部分将寄存器中的参数复制到在 register save area 内存区域，对于这6个寄存器来说，其位置有固定的从 register save area 开始的偏移 %rdi 0，%rsi 8,\u0026hellip;,%r9 40\nva_list 类型是只有一个元素的结构体数组：\nreg_save_area 指向 reg_save_area 区域； reg_save_area 初始时指向第一个由栈传递的参数（不包括寄存器保存在 register save area 的），每取一个由栈传递参数，自增该指针。 gp_offset 以字节为单位，从 register save area 到下一个要取的存放在 register save area 区域的寄存器参数的距离。假设 6 个通用目的寄存器中的参数都放在了该区域，且都被取完时，该值为 48。 typedef struct { unsigned int gp_offset; unsigned int fp_offset; void *overflow_arg_area; void *reg_save_area; } va_list[1]; 调用 va_args 取参数的算法大致先用 gp_offset 判断是否还能在 register save area 区域取到参数，如果可以，就在该区域取，取完一次后将 gp_offset += 8 . 如果该区域已经没有可以取的参数了，那么就通过 overflow_arg_area指针取出参数。\n# 2. 问题的分析与解决 # 现在原因已经很明显了，在 RISCV ABI 定义下， vsprintf() 向 handle_fmt() 传递了下一个要取的参数的地址，对于 handle_fmt()来说，这个地址就是一个局部变量，因此 va_args() 对其的改变并不会反映在 vsprintf()中。 这意味着，无论有多少个可变参数， va_list 永远都指向第一个可变参数。\n这可以通过一个简单的方法去验证，调用 sprintf(buf, \u0026quot;%d %d\u0026quot;, 1, 3) ，去检查 buf 区域的前三个字节，会发现依次为 0x31 0x20 0x31。 当然，这要保证函数 handle_fmt() 不被内联，在内联的情况下函数的行为也不会正确。\n可以通过给 gcc 传递-fopt-info-optimized-inline=inline.log ，将内联日志保存下来，去查看是否内联。也可以通过 objdump 去验证。\n要想解决这个问题，只需要将 va_list ap值传递改为引用传递。\n"},{"id":1,"href":"/notes/docs/cs/csapp/chapter2/%E8%AF%81%E6%98%8E%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E8%A1%A5%E7%A0%81%E5%8A%A0%E6%B3%95%E4%BD%8D%E7%BA%A7%E8%A1%A8%E7%A4%BA%E4%B8%80%E6%A0%B7/","title":"证明：无符号数和补码加法位级表示一样","section":"第二章","content":" 1.引入问题 # 在本章中，CSAPP定义了用长度为 \\(w\\) 的位向量编码无符号数与有符号数的方式，以及它们的各种算术运算。位向量可以写成两种形式 \\(\\vec{x}\\) 表示整个向量，或 \\([x_{w-1},...,x_0]\\) 形式，将其每一位表示出来。\n注意\n在考虑本章中位向量时，要注意的是，虽然它长相与二进制数相同，但在本章中的含义并不是二进制数，而是上面所说的位向量，也并未在这种向量上定义加法，例如 (10+01=11) ； 仅仅是使用0和1构成的串进行编码，每一位有根据其编码方式所定义的权重。\n现在考虑这样一个问题：设有 \\(w\\) 位的两个位向量 \\(\\vec{x}\\) 和 \\(\\vec{y}\\) , 考虑如下等式是否成立：\n\\[ U2B_w(B2U_w(\\vec{x}) +_{u}^{w} B2U_w(\\vec{y})) = T2B_w(B2T_w(\\vec{x}) +_{t}^{w} B2T_w(\\vec{y})) \\] 换句话说，将这两个向量转换成无符号数做加法，同时也将这两个数转换为有符号数做加法，再将两个加法的结果转换回向量形式，这两个向量是否相等？或者说，由于这两个加法是封闭的，加完之后的数一定也在各自相应的集合中，编码这两个数的位向量是否相同？\n2. 证明这个等式的意义是什么？ # 如果这个等式成立，这意味着可以用只需要用二进制数的加法就能同时计算补码和无符号数，那么就在机器指令层面就不需要区分无符号数和补码编码的数，只需要一条add指令即可完成这两种编码的数据的加法操作。如果对于减法、乘法、触发或是其他运算的该公式成立，那么ALU实现这些指令的时候，都不需要区分这两种数据编码方式。\n3.两个引理 # 想解决这个问题，需要先引入一些前置引理，来描述什么时候一个 \\(w\\) ​​ 位无符号数 \\(u = B2U_w(\\vec{u})\\) 和一个补码编码的有符号数 \\(t = B2U_w(\\vec{t})\\) 的向量相等。\n引理3.1：如果 \\(u - t = 0\\) ，则 \\(\\vec{u}=\\vec{t}\\) .\n引理3.2： 如果 \\(u - t = 2^w\\) ，则 \\(\\vec{u}=\\vec{t}\\) .\n理解这两个引理是理解本文要证明的内容的关键。先证引理3.1，此时 \\(t = u \\ge 0\\) ，根据补码的定义，它的符号位为 0 ，展开 \\(u - t = 0\\) 可以得到：\n\\[ \\begin{align*} \u0026\\sum_{i=0}^{w-1} u_i \\cdot 2^i - \\sum_{i=0}^{w-2} t_i \\cdot 2^i = 0 \\\\ \u0026u_{w-1} \\cdot 2^{w-1} + 2^{w-2}(u_{w-2} - t_{w-2}) + \\cdots + 2^0(u_0 - t_0) = 0 \\end{align*} \\] 由于其差为0，而等号左侧每一项大于等于0，因此可以推断出每一项都为0，即无符号数的最高为0，以及两个向量剩余的位是完全一样的。 \\( \\blacksquare \\) 再证引理3.2，此时\n\\[ \\begin{align*} t \u0026= u - 2^w \\le 2^{w} - 1 - 2^w = -1 \\\\ u \u0026= t + 2^w \\ge -2^{w-1} + 2^w = 2^{w-1} \\end{align*} \\] 因此， \\(\\vec{u},\\vec{t}\\) 的最高位必然1为，将 \\(u - t = 2^w\\) 展开观察： \\[ \\begin{align*} \u0026\\sum_{i=0}^{w-1} u_i \\cdot 2^i - \\sum_{i=0}^{w-1} t_i \\cdot 2^i = 2^w \\\\ \u00262^{w-1} + 2^{w-1} + 2^{w-2}(u_{w-2} - t_{w-2}) + \\cdots + 2^0(u_0 - t_0) = 2^w \\end{align*}， \\] 可以清楚看出的这两个向量的每一位都是一样的。 \\( \\blacksquare \\) 这个引理背后的直觉的与补码和无符号数编码定义有关，补码最高位被解释为负权重，当一个位向量最高位为1时，将他的补码数值转换为无符号数值时，就需要将该位视作一个正权，此时就要加上 \\( 2^w \\) 。所以，对于w位的补码数值，将它加上 \\( 2^w \\) 等于一个无符号数值时候，它们的位向量相同。\n4. 使用同余证明 # 4.1 同余知识 # 回忆：同余的定义 \\(a,b \\in \\Z，n \\in \\Z^+\\) ， \\(a\\) 与 \\(b\\) 模 \\(n\\) 同余 \\(\\iff\\) \\(a~mod~n = b~mod~n\\) ，记作 \\(a \\equiv b(mod~m) \\) . 回忆：同余的充分必要条件1 \\(a \\equiv b(mod~m) \\iff\\) \\(\\exist{k \\in \\Z}(a = b +km)\\) . 这个含义就是如果a和b模m同余当且仅当他们之间相差整数个m倍。\n引理4.1: 有 \\(w\\) 位无符号数 \\(u = B2U_w(\\vec{u})\\) 和一个补码编码的有符号数 \\(t = B2U_w(\\vec{t})\\) ，若 \\(u \\equiv t ~(mod~2^w)\\) ，则对于 \\( u = t + k2^w\\) ，其中 \\(k=0\\) 或 \\(k=1\\) .\n引理4.2: \\(u \\equiv t ~(mod~2^w) \\iff \\vec{u} = \\vec{t}\\) .\n充分性：根据引理4.1，先考虑 \\( k = 0时\\) ，此时 \\( u = t \\) ，根据引理3.1，我可知 \\( \\vec{u} = \\vec{t}\\) 。 再看 \\( k = 1时\\) ，此时 \\( u - t = 2^w\\) ，根据引理3.2，充分性得证。\n4.2 最终证明 # 回忆：一个关于同余的定理 \\( m \\in \\Z^+，a \\equiv b ~(mod~n), a \\equiv b ~(mod~n) \\rightarrow a +c\\equiv b+d ~(mod~n) \\) . 取两个 \\(w\\) 位的向量 \\(\\vec{x},\\vec{y}\\) , 记 \\(x_t = B2T_w(\\vec{x}) ,x_u = B2U_w(\\vec{x}),y_t = B2T_w(\\vec{y}) ,y_u = B2U_w(\\vec{y}) \\) ；根据引理4.2，有 \\(x_t \\equiv x_u (mod~2^w)，y_t \\equiv y_u (mod~2^w)\\) ，在根据上述定理，有\n\\[ x_t + y_t \\equiv x_u + y_u (mod~2^w) \\] ， 再通过引理4.2可知， \\(\\vec{x} = \\vec{y}. ~ ~ \\blacksquare \\) "},{"id":2,"href":"/notes/docs/cs/csapp/chapter2/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E4%B8%8E%E8%A1%A5%E7%A0%81%E5%8A%A0%E6%B3%95%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/","title":"无符号数与补码加法硬件实现","section":"第二章","content":" 无符号数与补码加法硬件实现 # 本文的目的要描述下面这个命题：\n使用传统的二进制数加法器就可以同时实现无符号数与补码的加法操作。 考虑实现一个无符号数加法的逻辑电路，他至少有两个输入 \\( \\vec{x}_w,\\vec{y}_w \\) ，作为参与加法的位向量的输入和一个位向量结果输出 \\( \\vec{z}_w \\) 。它的功能是：\n\\[ \\vec{z}_w = F( \\vec{x}_w,\\vec{y}_w )， \\] 其中 \\( \\vec{z}_w \\) 满足 \\( \\vec{z}_w = U2B_w(B2U_w(\\vec{x}_w) +B2U_w(\\vec{y}_w)). \\) 如果该电路要支持补码加法，那它同时也应该满足 \\( \\vec{z}_w = T2B_w(B2T_w(\\vec{x}_w) +B2T_w(\\vec{y}_w)). \\) 在上一节中，已经证明\n\\[ U2B_w(B2U_w(\\vec{x}) +_{u}^{w} B2U_w(\\vec{y})) = T2B_w(B2T_w(\\vec{x}) +_{t}^{w} B2T_w(\\vec{y})) \\] 是成立的，所以一个函数只要满足 \\( \\vec{z}_w = U2B_w(B2U_w(\\vec{x}_w) +B2U_w(\\vec{y}_w)) \\) ，那么它必然满足 \\( \\vec{z}_w = T2B_w(B2T_w(\\vec{x}_w) +B2T_w(\\vec{y}_w)). \\) 1. 位向量与二进制数的区别 # 首先，要区分开无符号数编码、补码编码与二进制数的区别。一个整数无论是什么进制，它有相同上数学的属性，为了更好的理解本章内容，考虑本章中的整数的时候都考虑其二进制写法；对于形如“001001”的二进制数，它属于整数集合 \\( \\Z^+ \\) . 更细化一点，我们可以定义为 \\( w \\) 二进制数定义一个集合：\n\\[ N_w = \\{b \\in \\N \\mid 0 \\le b \\le 2^w -1 \\}. \\] 而对于 \\( w \\) 位的一个编码串 (在CSAPP中被定义为位向量)，可以定义出它所属的集合：\n\\[ V_w = \\left\\{ [x_{w-1},...,x_0] \\mid \\forall i \\in \\{0,...,w-1\\}(x_i \\in {0,1}) \\right\\}. \\] 现在，可以很明显的看出来二进制数与所谓的向量之间的区别了。\n现在给出另一个有用的定义，它包括所有长度的位向量：\n\\[ V = \\bigcup_{k=1}^{\\infty} V_k \\] .\n2. 位向量转换为整数 # 为了更严谨的描述后续内容，对于 \\( w \\) 位向量 [1,0,0,1] , 有时候会需要将其转换为一个整数 1001 = 9；所以现在定一个具备该功能的函数：\n\\[ V2N: V \\rightarrow \\N \\\\ V2N(\\vec{v}_w) = \\sum_{i=0}^{w-1}{v_i \\cdot 2^{i}}， \\] 其中 \\( \\vec{v}_w\\) 是一个 w 位的位向量，而 \\( v_i\\) 是其分量。这是一个双射，所以存在反函数 \\( N2V :\\N \\rightarrow V\\) .\n这与 \\( B2U_w \\) 类似，但实际功能完全不同， 此处定义的函数可以以任意长度的位向量作为输入，并且输出是一个整数。而使用 \\( B2U_w \\) 时， 只能以w位的位向量作为输出。除了数学性质上的区别外，定义这个函数也在于将计算机中的无符号数以及用于其编码的位向量和数学上的整数区分开来。\n3. 无符号数加法与二进制数加法以及其电路实现 # 在开始前，先引入一个有用的函数 \\( TruncN_w: \\Z \\rightarrow \\Z \\) ，它将二进制数截断为 w 位：\n\\[ Trunc(x) = x~mod~2^w. \\] 现在开始分析无符号数加法与二进制数加法之间的关系，对于 \\( \\vec{x}_w,\\vec{y}_w \\) ,对其所编码的无符号数做无符号数加法操作，可以得到一个新的无符号数：\n\\[ u = B2U_w(\\vec{x}_w) +_w^u B2U_w(\\vec{y}_w) = \\begin{cases} B2U_w(\\vec{x}_w) + B2U_w(\\vec{y}_w) , \u0026 B2U_w(\\vec{x}_w) + B2U_w(\\vec{y}_w) \u003c 2^w\\\\ B2U_w(\\vec{x}_w) + B2U_w(\\vec{y}_w) - 2^w, \u0026 2^w \\le B2U_w(\\vec{x}_w) + B2U_w(\\vec{y}_w) \u003c 2^{w+1} \\end{cases} \\] 可以很明显的看出：\n对任意 \\(w\\) 位的两个位向量 \\(\\vec{x}\\) 和 \\(\\vec{y}\\) ，下式成立： \\[ V2N(\\vec{x}_w) + V2N(\\vec{y}_w) = B2U_w(\\vec{x}_w) + B2U_w(\\vec{y}_w) \\] 因此，无符号加法不溢出的时候有：\n\\[ V2N(\\vec{x}_w) + V2N(\\vec{y}_w) = V2N(U2B_w(u)) \\] 或者，当无符号数加法溢出时：\n\\[ V2N(\\vec{x}_w) + V2N(\\vec{y}_w) = V2N(U2B_w(u)) + 2^w \\] 因此，我们已经找到了本文开头的 F：\n\\[ F( \\vec{x}_w,\\vec{y}_w ) = U2B_w(u) = N2V(Trunc_w(V2N(\\vec{x}_w) + V2N(\\vec{y}_w))) . \\] 而在电路实现层面来看，电路并不区分位向量和二进制数，他们有相同的形式：高低电平。这几个公式解释了为什么可以通过二进制加法器来实现无符号数加法。根据本文开头的论证，这个电路也支持补码加法。\n"},{"id":3,"href":"/notes/docs/cs/csapp/chapter2/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%87%8F%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89/","title":"无符号数减法的定义","section":"第二章","content":" 整数运算中减法的定义： # 1.引入问题 # CSAPP并未定义无符号数和补码的减法运算，但是无论在编程中还是设计ALU中都需要用到该方面的知识，因此必须有一个系统性的了解。\n2.无符号数的减法 # 考虑如何定义无符号数减法遇到的第一个问题就是：对于正常的整数减法，小数减大数的结果为一个负数，但是\n无符号数并未给负数编码， 运算结果也不能为负数。 回忆：模运算处理负数 \\[-2~mod~8 = 6\\\\-3~mod~8=5\\\\...\\\\-8~mod~8=0\\\\-9~mod~8=7\\\\\\] 此时可以引入模运算来处理这种情况，这样就能解决上述的两个问题：当w位无符号数减法出现负数结果 a 时，让结果等于 \\( a~ mod~ 2^w = 2^w - |a| = 2^w+a\\) 。\n对于 \\(w\\) 位无符号数 \\(x,y\\) ，定义 \\(x-_w^u y =: (x-y)mod~2^w\\) \\( x,y \\) 分别取 0 和最大值，再反过来取，可以计算出减法的范围： \\(- 2^w - 1 \\le x-y \\le 2^w - 1\\) ，因此该定义可以写为\n\\( \\\\x -_w^u y = \\begin{cases} x - y, \u0026 x -y \\geq 0\\\\ x - y + 2^w, \u0026 x - y \u003c 0 \\end{cases} \\) 3. 使用加法逆元定义减法 # w位无符号数加法逆元 \\(\\forall x \\in [0,2^w)\\) ，其 \\(w\\) 位的无符号逆元 \\(-_w^u x\\) 由下式给出： \\[ -_w^u x = \\begin{cases} x, \u0026 x = 0 \\\\ 2^w - x, \u0026 x \u003e 0 \\end{cases} \\] 对于 \\(w\\) 位无符号数 \\(x,y\\) ，定义 \\(x-_w^u y =: x+(-_w^t y)\\) 将其代入无符号数加法公式，可以得到\n\\[ \\\\x -_w^u y = x+(-_w^t y) = \\begin{cases} x + (-_w^t y) , \u0026 x + (-_w^t y) \u003c 2^w\\\\ x +(-_w^t y) - 2^w, \u0026 2^w \\le x + (-_w^t y) \u003c 2^{w+1} \\end{cases} \\] 这种定义看起来并不直观，但是非常适用于ALU设计，因为在这种方法中，不需要额外的电路实现减法操作，只用加法电路就可以实现无符号数减法。\n4. 证明两种减法是等价的 # 可以通过证明下面这个等式成立，来证明两种减法的定义是等价的：\n\\[\\forall x,y \\in [~0,2^w)~((x-y)mod~2^w= x+(-_w^t y)) \\] .\n"},{"id":4,"href":"/notes/docs/cs/ysyx/ahstarct-machine/makefile/","title":"Makefile","section":"Ahstarct-machine","content":"11\n"},{"id":5,"href":"/notes/docs/cs/ysyx/nemu/makefile/","title":"Makefile","section":"NEMU","content":"11\n"},{"id":6,"href":"/notes/docs/cs/csapp/chapter9/","title":"第九章","section":"重读CSAPP","content":" 引言 # "},{"id":7,"href":"/notes/docs/cs/csapp/chapter2/","title":"第二章","section":"重读CSAPP","content":" 引言 # 第一次读这一章是我上大一的时候，当时每天不上课，几乎所有时间都花在了这本书上，大概一天也只能看个两三页。那个时候觉得这一章的内容太过于 “数学” 了，导致看的痛苦至极。\n这些年来也翻看过数遍这本书，现在由于想设计一个CPU，回过头来再精读这一章，却发现有些地方并不是很严谨，涉及的内容也不够完整，缺失了一些内容与定义，考虑如下一些内容：\n本章提及的位向量、二进制数以及整数之间的关系是什么，如何形式化地描述这些差异？ 无符号数加法和补码加法的位级表示是否一样，为什么，又该如何证明？ 对于同一个位向量，它的无符号数的加法逆元和补码的加法逆元位向量是否相同？如何证明？ 无符号数较小的数字减去一个较大的数字时，该如何处理，结果是什么？ 无符号数与补码的减法如何定义？ 这些都是本章所缺失但又极其重要的内容，我在接下来的几篇文章要详细讨论上述内容。\n"},{"id":8,"href":"/notes/docs/cs/csapp/chapter2/%E8%A1%A5%E7%A0%81%E5%87%8F%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89/","title":"补码减法的定义","section":"第二章","content":" 补码减法 # 1. 定义补码减法的思路 # 在定义一种新运算时，首先要考虑如下几个问题：\n是否会出现未被编码的结果，例如在无符号数减法中，结果为负数。 是否会出现溢出，溢出的条件是什么，溢出时如何处理？ 在做w位补码减法时，所有结果都被编码了，但是w位无法容纳发生溢出时的结果：一个正数减去一个负数的结果可能大于 \\(2^{w-1} - 1\\) ，此时与补码加法正溢出类似；同样，一个负数减去一个正数可能会小于 \\(-2^{w-1}\\) ，这时称减法发生了负溢出。\n对于 \\(w\\) 位补码 \\(x,y\\) ，定义补码减法为： \\( \\\\x-_w^t y =: \\begin{cases}x - y - 2^w, \u0026 x - y \\ge 2^{w-1}\\\\ x-y, \u0026 -2^w \u003c x-y \u003c 2^{w-1} \\\\x - y + 2^w, \u0026 x-y \\le -2^{w-1} -1 \\end{cases} \\) 2.使用加法逆元定义补码减法 # 为了方便硬件实现减法，此处给出一种使用补码加法实现补码减法的定义。\nw位无符号数加法逆元 \\(\\forall x \\in [-2^{w-1},2^{w-1}-1]\\) ，其 \\(w\\) 位的补码加法逆元 \\(-_w^t x\\) 由下式给出： \\[ -_w^t x = \\begin{cases} x, \u0026 x = -2^{w-1} \\\\ -x \u0026 x \u003e -2^{w-1} \\end{cases} \\] 对于 \\(w\\) 位补码 \\(x,y\\) ，定义 \\(x-_w^t y =: x+_w^t (-_w^t y)\\) 将其代入补码加法公式，可以得到\n\\[ x +_w^t (-_w^t y) = \\begin{cases} x + (-_w^t y) - 2^w, \u0026 \\quad 2^{w-1} \\le x + (-_w^t y) \\\\ x + (-_w^t y), \u0026 \\quad -2^{w-1} \\le x + (-_w^t y) \u003c 2^{w-1} \\\\ x + (-_w^t y) + 2^w, \u0026 \\quad x + (-_w^t y) \u003c -2^{w-1} \\end{cases} \\] "},{"id":9,"href":"/notes/docs/cs/csapp/chapter2/%E5%8A%A0%E6%B3%95%E9%80%86%E5%85%83%E7%9A%84%E4%BD%8D%E5%90%91%E9%87%8F/","title":"加法逆元的位向量","section":"第二章","content":" 加法逆元的位向量 # 1. 引言 # 本文要证明如下命题：\n对于任意 \\(w\\) 位位向量 \\(\\vec{x}\\) ， \\( T2B_w(-_w^t B2T_w(\\vec{x})) = U2B_w(-_w^u B2U_w(\\vec{x}))\\) . 在实现无符号数和补码减法时，可以把减法替换成加法，加上被减数的加法逆元，如果该命题成立，只需要一个变量即可。\n2.证明 # 可以分两种情况证明，先考虑 \\(B2T_w(\\vec{x}) = B2U_w(\\vec{x})\\) 时，\n"},{"id":10,"href":"/notes/docs/hugo/%E5%8E%BB%E6%8E%89%E5%BA%95%E9%83%A8%E5%B9%BF%E5%91%8A/","title":"去掉Hugo Blox模板底部广告","section":"Hugo","content":" 1 # "},{"id":11,"href":"/notes/docs/hugo/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%98%AF%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E7%9A%84/","title":"我的Page是如何搭建的","section":"Hugo","content":" 1 # "},{"id":12,"href":"/notes/docs/cs/arch/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":" 4th Level of Menu # Caesorum illa tu sentit micat vestes papyriferi # Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":13,"href":"/notes/docs/cs/arch/3rd-level/","title":"3rd Level","section":"计算机体系结构","content":" 3rd Level of Menu # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp); "},{"id":14,"href":"/notes/docs/cs/automaton/%E4%B8%8A%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/out/","title":"Out","section":"自动机理论","content":"状态最小化算法一些思考（来自《Elements of the theroy of the computation》 P62）：\n在考虑问题前，先考虑一些问题。首先， \\( \\equiv_n\\) 是什么： 这是一个等价关系， \\( \\equiv_n \\subseteq K \\times K\\) ，其中每个元素的两个状态就是对于任意同一个长度小于等于n的串要么接受，要么不接受。\n算法第 \\(k\\) 次迭代完成，维护了等价关系： \\( \\equiv_{k}\\) 。\n\\(\\forall{p \\in K} ~ \\forall q \\in K(p \\equiv_{100}q \\iff p \\equiv_{99}q)\\) 意味着什么：这两个等价关系的元素完全相同。\n算法在进行第 \\(k\\) 次迭代时候，会进行如下操作：对 \\(\\equiv_{k}\\) 中每一个 \\((p,q)\\) ，检测 \\(\\forall{a \\in \\Sigma}((\\delta(p,a),\\delta(q,a))\\in \\equiv_{k-1})\\) , 根据定理2.5.1， 如果在这个关系中，那么说明 \\(p\\equiv_{k}q\\) 。\n如何通过 \\(\\forall{p \\in K} ~ \\forall q \\in K(p \\equiv_{n-1}q \\iff p \\equiv_{n}q)\\) 推导出 \\( \\forall{p \\in K} ~ \\forall q \\in K(p \\equiv_{n+1}q \\iff p \\equiv_{n}q)\\) ，可以通过两个角度来思考这个问题：\n一、 直觉 # 如果 \\(\\forall{p \\in K} ~ \\forall q \\in K(p \\equiv_{n-1}q \\iff p \\equiv_{n}q)\\) 成立， 说明 \\(\\equiv_{n-1}~= ~\\equiv_{n}\\) 。\n考虑 \\(n=100\\) 成立时，即此时要进行第 101 次迭代，会对 \\(\\equiv_{100}\\) 中每一个 \\((p,q)\\) 检测 \\(\\forall{a \\in \\Sigma}((\\delta(p,a),\\delta(q,a))\\in \\equiv_{100})\\) ，而由于 \\(\\equiv_{100}~= ~\\equiv_{99}\\) ，这相当于重复进行了一次 \\(n=99\\) 时的迭代，因为要检测的等价关系是完全一样的。因此可以保证 \\(\\equiv_{101}~= ~\\equiv_{100}\\) 。\n二、从代数的角度考虑 # 为什么：如果 \\(\\forall{p \\in K} ~ \\forall q \\in K(p \\equiv_{n-1}q \\iff p \\equiv_{n}q)\\) 成立，为什么 \\(\\forall{a \\in \\Sigma}((\\delta(p,a),\\delta(q,a))\\in \\equiv_{n})\\) 一定成立？\n考虑要进行第n+1次迭代时，根据定理2.5.1的充分性，可以知道 \\(\\forall{a \\in \\Sigma}((\\delta(p,a),\\delta(q,a))\\in \\equiv_{n-1})\\) ，由于 \\(\\forall{p \\in K} ~ \\forall q \\in K(p \\equiv_{n-1}q \\iff p \\equiv_{n}q)\\) 成立，即 \\(\\equiv_{n-1}~= ~\\equiv_{n}\\) ， 所以 \\(\\forall{a \\in \\Sigma}((\\delta(p,a),\\delta(q,a))\\in \\equiv_{n})\\) 。 所以一定可以检测成功。\n"},{"id":15,"href":"/notes/docs/cs/csapp/chapter2/0%E6%89%A9%E5%B1%95%E7%9A%84%E5%8A%A0%E6%B3%95/","title":"0扩展的加法","section":"第二章","content":" 1.引言 # 在使用HDL实现 \\( w \\) 位ALU时，对于参与加法的 \\( w \\) 位的位向量 \\( [x_{w-1},...,x_{0}]， [y_{w-1},...,y_{0}] \\) ， 需要通过0扩展将参与加法的两个数扩展到 \\( w + 1\\) 位，加法后得到一个结果 \\( [z_w,z_{w-1},...,z_{0}] \\) ，然后取 \\( [z_{w-1},...x_0] \\) 作为 ALU 的加法结果的输出，并通过 \\( z_w \\) 来判断是否设置 carry flag。除此之外，补码加法同样使用无符号数加法的同一份电路，因此，也需要判断0扩展后，补码的加法是否还保持一样。\n为了方便描述本文内容，可以给出两个函数的定义，一个截断位向量： \\( TruncaV_w: V \\rightarrow V_w \\) ，一个扩展位向量: \\(Ext: V_q \\times V_p \\rightarrow V_{p+q} \\) 。\n定义：\n而本文要证明,对任意 \\(w\\) 位的两个位向量 \\(\\vec{x}\\) 和 \\(\\vec{y}\\) ，下式成立：\n\\[B2U_w(\\vec{x}) +_w^u B2U_w(\\vec{y}) = B2U_w(TruncV_w(N2V(V2N(Ext([0], \\vec{x})) + V2N(Ext([0], \\vec{y}))))，\\] 之所以等式右侧使用V2N转换为二进制数做加法，是因为我们的ALU中加法器电路是二进制加法器电路。\n以及证明：\n\\[B2T_w(\\vec{x}) +_w^u B2T_w(\\vec{y}) = B2T_w(TruncV_w(N2V(V2N(Ext([0], \\vec{x})) + V2N(Ext([0], \\vec{y})))).\\] 2.无符号数证明 # 对于整数，在其前面加上若干个0，并不会改变它的值，因此有：\n\\[ V2N(Ext([0], \\vec{x})) + V2N(Ext([0], \\vec{y})) = V2N(\\vec{x}) + V2N(\\vec{y}) . \\] 而\n\\[ V2N(\\vec{x}) + V2N(\\vec{y}) = B2U_w(\\vec{x}_w) + B2U_w(\\vec{y}_w) . \\] \\( B2U_w(\\vec{x}_w) + B2U_w(\\vec{y}_w)\\) 与 \\(B2U_w(\\vec{x}) +_w^u B2U_w(\\vec{y})\\) 要么相等，要么多了 \\( 2^w\\) . 所以将 \\(N2V(V2N(Ext([0], \\vec{x})) + V2N(Ext([0], \\vec{y}))\\) 截断到 w 位后，一定与 \\(B2U_w(\\vec{x}) +_w^u B2U_w(\\vec{y})\\) 的位向量相同。\n3. 补码证明 # 由于对任意 \\(w\\) 位的两个位向量 \\(\\vec{x}\\) 和 \\(\\vec{y}\\) ，下式成立：\n\\[B2U_w(\\vec{x}) +_w^u B2U_w(\\vec{y}) = B2U_w(TruncV_w(N2V(V2N(Ext([0], \\vec{x})) + V2N(Ext([0], \\vec{y}))))，\\] 对该等式两边与 U2B 复合后，依旧成立：\n\\[U2B_w(B2U_w(\\vec{x}) +_w^u B2U_w(\\vec{y})) = TruncV_w(N2V(V2N(Ext([0], \\vec{x})) + V2N(Ext([0], \\vec{y}))).\\] 已经证明过，对任意 \\(w\\) 位的两个位向量 \\(\\vec{x}\\) 和 \\(\\vec{y}\\) ，下式成立：\n\\[ U2B_w(B2U_w(\\vec{x}) +_{u}^{w} B2U_w(\\vec{y})) = T2B_w(B2T_w(\\vec{x}) +_{t}^{w} B2T_w(\\vec{y})). \\] 因此，对任意 \\(w\\) 位的两个位向量 \\(\\vec{x}\\) 和 \\(\\vec{y}\\) ，有\n\\[ T2B_w(B2T_w(\\vec{x}) +_{t}^{w} B2T_w(\\vec{y})) = TruncV_w(N2V(V2N(Ext([0], \\vec{x})) + V2N(Ext([0], \\vec{y}))). \\] 两侧同时与 B2T 复合，因为\u0026hellip;.，等式依旧成立：\n"},{"id":16,"href":"/notes/docs/cs/csapp/chapter2/cpp%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1/","title":"Cpp类型转换陷阱","section":"第二章","content":"weight = 50 title: \u0026#34;C++ 数据类型转换陷阱\u0026#34; C/C++ 数据类型转换陷阱 # 考虑如下代码中, result的值是什么？\nunsigned char data1 = 0b1100\u0026#39;0000; unsigned char data2 = 0b1000\u0026#39;0000; bool result = (data2 == (data1 \u0026lt;\u0026lt; 1)); 引用cppreference的一段话：\nIntegral promotion # prvalues of small integral types (such as char) and unscoped enumeration types may be converted to prvalues of larger integral types (such as int). In particular, arithmetic operators do not accept types smaller than int as arguments, and integral promotions are automatically applied after lvalue-to-rvalue conversion, if applicable. This conversion always preserves the value.\n\u0026hellip;.\nif the integer conversion rank of T is lower than the rank of int: val can be converted to a prvalue of type int if int can represent all the values of T; otherwise, val can be converted to a prvalue of type unsigned int. \u0026hellip;.\n根据定义， \u0026lt;\u0026lt; 是算术运算符， 因此 (data1 \u0026lt;\u0026lt; 1) 的结果会提升为int类型。 而 data2 == (data1 \u0026lt;\u0026lt; 1)中的data2 和后者类型不同，因此会根据 Usual arithmetic conversions 提升为 int。 是否会扩展符号位？ 暂时不知道。\n再分析这个：\nunsigned char data1 = 0b1000\u0026#39;0000; signed char data2 = 0b1000\u0026#39;0000; bool result = (data2 == (data1)); "},{"id":17,"href":"/notes/docs/cs/csapp/chapter2/c%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%99%B7%E9%98%B1%E9%99%A4%E6%B3%95/","title":"C类型转换陷阱：除法","section":"第二章","content":" C类型转换陷阱：除法 # 在实现nemu表达式求值时，需要生成若干随机表达式来测试程序真确性，生成表达式后，自然也要计算其正确结果，然后nume再计算这个表达式的结果，与刚才计算的正确结果相比较。\n在一开始时我错误的将 eval() 函数写成了具有 int 类型返回值， 而正确结果计算时候，每一个操作数的数据类型全是无符号数，因此导致了两个结果不相等。尽管只需要将 eval(...)返回值修改成无符号数就可以让两次求值结果相同，但是还是值得探究一下其原因，我将这个问题在本文中简化并且抽象出来了。\n考虑如下代码中, a和b 的值是什么？\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = -5 / -6; unsigned int b = (unsigned int)-5 / (unsigned int)-6; printf(\u0026#34;a: %d, b: %u\\n\u0026#34;, a, b); return 0; } 在int 和 unsigned int 都是32位的情况下，该程序的输出如下\na: 0, b: 1 a 的值很明显，因为 -5/-6 = 0.83333... ，根据c语言整数除法，只会保留 0 作为结果。 现在考虑 b 的值， 将 -5 转化为 32 位无符号数应为 4294967291 ,而 -6 为 4294967290， 所以 b = 4294967291 / 4294967290 = 1.000000232831 ，c 语言为其保留整数部分，所以 b 的值就是 1 。\n后续工作（1）：一个需要证明的命题 # 因此是否可以断言 给定两个数，分别做整数除法和无符号数除法，其结果位向量不一定相同？ 那对于乘法呢？\n后续工作（2）：学习C语言中对表达式求值时的数据类型转换 # 例如一个32位无符号数除以16位有符号数，该如何计算？答案在https://en.cppreference.com/w/c/language/conversion.html里。\n"},{"id":18,"href":"/notes/docs/cs/hidden/","title":"Hidden","section":"计算机","content":" This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris # Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":19,"href":"/notes/docs/cs/linuxsysprograming/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":" 4th Level of Menu # Caesorum illa tu sentit micat vestes papyriferi # Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":20,"href":"/notes/docs/cs/linuxsysprograming/3rd-level/","title":"3rd Level","section":"Linux系统编程","content":" 3rd Level of Menu # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp); "},{"id":21,"href":"/notes/docs/cs/ysyx/ahstarct-machine/makefile/%E8%B7%9F%E8%B8%AAmake%E5%91%BD%E4%BB%A4/","title":"跟踪make命令","section":"Makefile","content":" 跟踪make命令 # 1.从make ARCH=riscv32-nemu run开始 # 首先，进入ysyx-workbench/am-kernels/kernels/hello目录，运行make ARCH=riscv32-nemu run -nB 命令。其中\nARCH=riscv32-nemu 定义了一个变量，在 Makefile 中即便没有 ARCH = ...这样的定义，也可以直接通过$(ARCH)使用这个变量。 run 意味着会执行名为 run的规则。 -n表明要只输出执行的规则，而不真正的执行。 -B 不论新旧，强制执行所有依赖的规则。 将该命令的结果输出到vim中，简单浏览一遍，发现有如下规律：\n有的地方执行了 make 命令，因此可以暂时先用 :%!grep \u0026quot;^make\u0026quot; 过滤出来简单查看。 但是发现有形如 make[1]的make输出，因此需要只保留make作为命令执行的行。 以 gcc,g++以及riscv 开头的命令大概率是编译、链接的命令。 在最底下，能看到 nemu 被执行的命令，这一行可以先不保留。 因此，可以通过这样的思路来清洗输出：保留上述列出的三项内容的行，筛选掉其他的行，可命令 %!grep -E \u0026quot;^make *-|^riscv|gcc|g\\+\\+\u0026quot; 实现，加 -E 是因为 grep 默认不支持或运算符。执行完该命令后，可以发现，编译一些单独的.c源文件就有大量重复的内容：\n-std=gnu11 -O2 -MMD -Wall -Werror -I/home/ubuntu/ysyx-workbench/abstract-machine/am/src -I/home/ubuntu/ysyx-workbench/abstract-machine/am/include -I/home/ubuntu/ysyx-workbench/abstract-machine/am/include/ -I/home/ubuntu/ysyx-workb ench/abstract-machine/klib/include/ -D__ISA__=\\\u0026#34;riscv32\\\u0026#34; -D__ISA_RISCV32__ -D__ARCH__=riscv32-nemu -D__ARCH_RISCV32_NEMU -D__PLATFORM__=nemu -D__PLATFORM_NEMU -DARCH_H=\\\u0026#34;arch/riscv.h\\\u0026#34; -fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector -Wno-main -U_FORTIFY_SOURCE -fvisibility=hidden -fno-pic -march=rv64g -mcmodel=medany -mstrict-align -march=rv32im_zicsr -mabi=ilp32 -static -fdata-sections -ffunction-sections -I/home/ubuntu/ysyx-workbench/abstract-machine/am/src/platform/nemu/incl ude -DMAINARGS_MAX_LEN=64 -DMAINARGS_PLACEHOLDER=\\\u0026#34;\u0026#34;The insert-arg rule in Makefile will insert mainargs here.\u0026#34;\\\u0026#34; -DISA_H=\\\u0026#34;riscv/riscv.h\\\u0026#34; 可以简单的用:%s/foo/bar/g替换掉，这表示在整个文件中（%），把所有匹配 foo 的内容替换为 bar，g 表示每一行中所有匹配都替换。可以用正则表达式中.,*两个元字符，句号代表匹配任意字符一次，而星号表示匹配前一个字符0次或任意多次。\n此时还会发现有很多 gcc ... -E ...的行，这仅仅进行了预编译处理，可以删掉这些行。可以使用:g/{pattern}/[command],该命令对所有匹配 {pattern} 的行，执行指定的 [command]。 command用d 可以删掉匹配到的行。\n最后，再用%s/ -/\\r -/g将每个以 -开头的参数换行。\n现在可以看到，make执行的命令主要分为两部分：\n编译hello所需的源文件，然后链接在一起，这用了一个额外的链接脚本。 编译并链接nemu。 这两部分通过如下这条make命令连接，这是调用nemu的Makefile，以刚刚完成编译的hello作为参数，运行nemu的命令：\nmake -C /home/ubuntu/ysyx-workbench/nemu ISA=riscv32 run ARGS=\u0026#34;-l /home/ubuntu/ysyx-workbench/am-kernels/kernels/hello/build/nemu-log.txt\u0026#34; IMG=/home/ubuntu/ysyx-workbench/am-kernels/kernels/hello/build/hello-riscv32-nemu.bin 以及最后一行的命令输出：\n/home/ubuntu/ysyx-workbench/nemu/build/riscv32-nemu-interpreter -l /home/ubuntu/ysyx-workbench/am-kernels/kernels/hello/build/nemu-log.txt /home/ubuntu/ysyx-workbench/am-kernels/kernels/hello/build/hello-riscv32-nemu.bin 2. 分析hello是如何被编译、链接的 # 对于linux下的C程序，它的入口点是 _start , 这个符号（Symbol）是由 ctr1.o 提供的, 并且在链接脚本里通过ENTRY(_start) 设置了程序入口点，这个关键词会让链接器将elf头中的程序入口点字段设置为 _start的地址。\n对于命令 gcc a.c 来说，它会自用调用链接器，而当我们手动调用链接器链接目标文件时候，需要我们手动提供 ctri.o 。当然， gcc 实际上也是调用 ld，并提供了相应的参数，用如下命令可以追踪 gcc 是如何调用 ld的：\nstrace -f -s 10000 -e execve gcc a.c 2\u0026gt;\u0026amp;1 | grep /ld strace用于追踪系统调用， -e execve 指明了只追踪 execve， -f 表明要追踪 gcc 创建的子进程的系统调用。\n执行该命令，并检查execve的第二个参数，可以看到如下内容：\n/usr/bin/ld -plugin /usr/libexec/gcc/x86_64-linux-gnu/13/liblto_plugin.so .... --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro -o a.out /usr/lib/gcc/x86_64-linux-gnu/13/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/13/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/13/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/13 -L/usr/lib/gcc/x86_64-linux-gnu/13/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/13/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/13/../../.. /tmp/ccszOHmP.o ... 可以看到里面就有 /usr/lib/gcc/x86_64-linux-gnu/13/../../../x86_64-linux-gnu/crti.o.\n此外，需要值得注意的是，ENTRY(_start) 不会告诉链接器要将 _start 部分的代码放到可执行文件的哪里，也不会告诉链接器如何设置 _strart部分代码的运行时地址。\n3. am 链接自己的 _start # 首先分析一下链接 hello的参数：\nriscv64-linux-gnu-ld -z noexecstack -T$(A)/scripts/linker.ld -melf64lriscv --defsym=_pmem_start=0x80000000 --defsym=_entry_offset=0x0 --gc-sections -melf32lriscv -o /home/ubuntu/ysyx-workbench/am-kernels/kernels/hello/build/hello-riscv32-nemu.elf --start-group /home/ubuntu/ysyx-workbench/am-kernels/kernels/hello/build/riscv32-nemu/hello.o $(A)/am/build/am-riscv32-nemu.a $(A)/klib/build/klib-riscv-32-nemu.a --end-group 重点关注， --start-group...--end-group 部分，这是链接器的输入，并且可以打乱输入文件的顺序也能找到相应的符号。 可以看到hello.o 和两个.a 文件链接在了一起。.a 一般作为linux静态链接库后缀，一个静态链接库本质上就是一组可重定位目标文件的集合，可以通过 ar将一组可重定位目标文件打包为一个静态链接库。\n通过分析刚才make的输出，可以清楚的看到这两个静态链接库是如何被打包的：\nriscv64-linux-gnu-ar rcs $(A)/am/build/am-riscv32-nemu.a $(A)/am/build/riscv32-nemu/src/platform/nemu/trm.o $(A)/am/build/riscv32-nemu/src/platform/nemu/ioe/ioe.o $(A)/am/build/riscv32-nemu/src/platform/nemu/ioe/timer.o $(A)/am/build/riscv32-nemu/src/platform/nemu/ioe/input.o $(A)/am/build/riscv32-nemu/src/pl atform/nemu/ioe/gpu.o $(A)/am/build/riscv32-nemu/src/platform/nemu/ioe/audio.o $(A)/am/build/riscv32-nemu/src/platform/nemu/ioe/disk.o $(A)/am/build/riscv32-nemu/src/platform/nemu/mpe.o $(A)/am/build/riscv32-nemu/src/riscv/nemu/start.o $(A)/am/build/riscv32-nemu/src/riscv/nemu/cte.o $(A)/am/build/riscv32-nemu/src/riscv/nemu/trap.o $(A)/am/build/riscv32-nemu/src/riscv/nemu/vme.o riscv64-linux-gnu-ar rcs $(A)/klib/build/klib-riscv32-nemu.a $(A)/klib/build/riscv32-nemu/src/stdio.o $(A)/klib/build/riscv32-nemu/src/int64.o $(A)/klib/build/riscv32-nemu/src/stdlib.o $(A)/klib/build/riscv32-nemu/src/cpp.o $(A)/klib/build/riscv32-nemu/src/string.o 而riscv32-nemu的 _start 就定义在 $(A)/am/build/riscv32-nemu/src/riscv/nemu/start.o 中，可以根据 make 的输出定位到在$(A)/am/src/riscv/nemu/start.S 中。其内容如下：\n.section entry, \u0026#34;ax\u0026#34; .globl _start .type _start, @function _start: mv s0, zero la sp, _stack_pointer call _trm_init 现在再看一下链接脚本：\nENTRY(_start) PHDRS { text PT_LOAD; data PT_LOAD; } SECTIONS { /* _pmem_start and _entry_offset are defined in LDFLAGS */ . = _pmem_start + _entry_offset; .text : { *(entry) *(.text*) } : text etext = .; _etext = .; .rodata : { *(.rodata*) } .data : { *(.data) } : data edata = .; _data = .; .bss : { _bss_start = .; *(.bss*) *(.sbss*) *(.scommon) } _stack_top = ALIGN(0x1000); . = _stack_top + 0x8000; _stack_pointer = .; end = .; _end = .; _heap_start = ALIGN(0x1000); } 首先，ENTRY(_start) 指定了程序入口点。 然后, . = _pmem_start + _entry_offset; 设置了后续内容的开始的 VMA。\n下一条一句指定了如何生成 elf 文件的 .text 段，* 是通配符，匹配任意字符，放在 section 名字前，代表取所有输入文件的某个 section：\n*(entry) 取所有输入文件的 entry section，放在 elf 的.textsection的开头，\n*(.text*) 取所有输入文件中以 .text 开头的section，放在上述 section 的后面。\n"},{"id":22,"href":"/notes/docs/cs/ysyx/ahstarct-machine/makefile/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/","title":"阅读源码","section":"Makefile","content":" 阅读源码 # 1. 继续从make ARCH=riscv32-nemu run开始 # 在ysyx-workbench/am-kernels/kernels/hello目录中，有一个 Makefile文件，在该目录下运行这条命令，自然会从这个文件里寻找规则去执行，因此先查看该文件的内容：\nNAME = hello SRCS = hello.c include $(AM_HOME)/Makefile SRCS 是一个非常重要的变量，它收集了本次运行make 所产生的进程的所有要编译的源文件（这是因为 makefile 文件里会再次执行make命令，编译 klib 和abstract-machine）。\n其中，$(AM_HOME)/Makefile 是最核心的 makefile 文件，在检查这个文件内容，可以发现如下include链：\n~/ysyx-workbench/am-kernels/kernels/hello/Makefile ↓ $(AM_HOME)/Makefile ↓ $(AM_HOME)/scripts/riscv32-nemu.mk ↙ ↘ $(AM_HOME)/scripts/isa/riscv.mk $(AM_HOME)/scripts/platform/nemu.mk $(AM_HOME)/Makefile 的主要用处： 根据传入的 ARCH 参数 \u0026hellip;\n定义了 CC,LD,CCFLAG,LDFLAGS等变量，以及所有架构、平台可以共用的这些参数。\n定义了如何编译、链接你要跑的应用，在这里就是hello，同时也用相同的规则定义了 abstract-machine和 kilb 的编译为目标文件的规则，以及打包成静态库（递归调用）。\n$(AM_HOME)/scripts/isa/riscv.m :\n主要是 ISA 相关的内容， $(AM_HOME)/scripts/platform/nemu.mk :\n2. 先分析主Makefile中的 ARCH 变量 # 3. 从 run 规则开始分析 # run规则定义在平台相关的 $(AM_HOME)/scripts/platform/nemu.mk 中：\ninsert-arg: image @python $(AM_HOME)/tools/insert-arg.py $(IMAGE).bin $(MAINARGS_MAX_LEN) \u0026#34;$(MAINARGS_PLACEHOLDER)\u0026#34; \u0026#34;$(mainargs)\u0026#34; image: image-dep @$(OBJDUMP) -d $(IMAGE).elf \u0026gt; $(IMAGE).txt @echo + OBJCOPY \u0026#34;-\u0026gt;\u0026#34; $(IMAGE_REL).bin @$(OBJCOPY) -S --set-section-flags .bss=alloc,contents -O binary $(IMAGE).elf $(IMAGE).bin run: insert-arg $(MAKE) -C $(NEMU_HOME) ISA=$(ISA) run ARGS=\u0026#34;$(NEMUFLAGS)\u0026#34; IMG=$(IMAGE).bin 而其最终所依赖的 image 定义在 $(AM_HOME)/Makefile中：\nimage: image-dep archive: $(ARCHIVE) image-dep: $(LIBS) $(IMAGE).elf 在看 IMAGE的定义：\nIMAGE_REL = build/$(NAME)-$(ARCH) IMAGE = $(abspath $(IMAGE_REL)) 在开始后续分析前，先看一眼定义在该makefile中的 WORK_DIR 变量：\nWORK_DIR = $(shell pwd) DST_DIR = $(WORK_DIR)/build/$(ARCH) 尽管这是在 $(AM_HOME)/Makefile的定义的，但是这个文件是被 $YSYX/am-kernels/kernels/hello/Makefile include 进来了，而 make命令是在 $YSYX/am-kernels/kernels/hello 目录下运行的，所以 WORK_DIR 的值也是这个目录。\n继续我们的分析，IMAGE 的值就是将 build/hello-riscv32-neum 转换为绝对路径，现在可以看$(IMAGE) 是如何被编译的了：\n$(IMAGE).elf: $(/) $(LDSCRIPTS) @echo \\# Creating image [$(ARCH)] @echo + LD \u0026#34;-\u0026gt;\u0026#34; $(IMAGE_REL).elf OBJS = $(addprefix $(DST_DIR)/, $(addsuffix .o, $(basename $(SRCS)))) LIBS := $(sort $(LIBS) am klib) # lazy evaluation (\u0026#34;=\u0026#34;) causes infinite recursions LINKAGE = $(OBJS) \\ $(addsuffix -$(ARCH).a, $(join \\ $(addsuffix /build/, $(addprefix $(AM_HOME)/, $(LIBS))), \\ $(LIBS) )) 先看一下内建函数join的效果：$(join a b c, 1 2 3) 的结果为 a1 b2 c3。注意，addprefix和addsufix是会给每个由空格隔开的单词都加上相同的前缀或后缀：$(addprefix a, 1 2) 的结果为 a1 a2.\n上面代码中的 join 两个参数分别为 ：\n$(addsuffix /build/, $(addprefix $(AM_HOME)/, $(LIBS))) $(LIBS) 最终，LINKAGE 的结果就是 $(DST_DIR)/build/xxx.o 和 两个位于am/build 以及 klib/build中的 .a\n"},{"id":23,"href":"/notes/docs/cs/ysyx/nemu/makefile/%E5%9F%BA%E6%9C%AC%E7%BB%84%E7%BB%87/","title":"基本组织","section":"Makefile","content":" 基本组织 # 1.项目目录下的Makefile文件结构 # . 为nemu根目录，在nume项目根目录下，可以看到有很多makefile文件：\nnemu |── Makefile ├── scripts │ ├── build.mk │ ├── config.mk │ └── native.mk ├── src ├── filelist.mk ├── device │ └── filelist.mk ├── engine │ └── filelist.mk ├── filelist.mk ├── isa │ └── filelist.mk └── utils └── filelist.mk 项目根目录下的Makefile 文件并没有实际的目标定义，而是一系列的变量与 include语句，将其他makefile文件包含进来。 其中一个非常重要的变量为 SRCS , 这个变量收集了所有要参与编译的 .c 文件。\nnemu/src/.. 目录下的 filelist.mk 主要做了三件事情：\n给SRCS-y变量追加单个的.c文件名， 给DIRS-y 追加搜索 .c 文件的目录， 添加.c文件黑名单。 scripts 目录下的 makefile 文件定义编译用的目标与各种依赖。其中：\nnative.mk 主要定义了使用最频繁的run 目标。 build.mk 主要定义了一个 .c 文件如何编译成 .o文件的目标，以及如何将这些.o链接成nemu可执行文件。 2. 从 make run 的角度打开 Makefile # 先简单看一下 make run 的定义：\n-----------------nume/scrpits/native.mk------------------- ... compile_git: $(call git_commit, \u0026#34;compile NEMU\u0026#34;) $(BINARY):: compile_git ... run-env: $(BINARY) $(DIFF_REF_SO) NEMU_EXEC := $(BINARY) $(ARGS) $(IMG) ... run: run-env $(call git_commit, \u0026#34;run NEMU\u0026#34;) $(NEMU_EXEC) 可以通过变量名字猜测出 $(NEMU_EXEC)或者说$(BINARY) $(ARGS) $(IMG) 的作用就是执行实际的 nemu 程序，并给定相应的参数，以及要读入的二进制文件。而 run 和 run-env 都是伪目标，因此当运行 make run 时，目标 run-env 一定会被执行一次。\n现在来关注一下$(BINARY) ， 这不仅是一个变量，而且还用这个变量定义了两个目标，注意定义目标时用的是双引号$(BINARY)::..，这被称为 Double-colon rules ，意味着可以有多个同名的目标，每次执行该目标时，会检测每个有这个名字的目标的依赖，来判断是否执行该目标。\n$(BINARY) 变量以及另外一个名为$(BINARY) 的目标被定义在 scripts/build.mk 中：\n-----------------nume/scrpits/build.mk------------------- ... SO = -so WORK_DIR = $(shell pwd) BUILD_DIR = $(WORK_DIR)/build INC_PATH := $(WORK_DIR)/include $(INC_PATH) OBJ_DIR = $(BUILD_DIR)/obj-$(NAME)$(SO) BINARY = $(BUILD_DIR)/$(NAME)$(SO) OBJS = $(SRCS:%.c=$(OBJ_DIR)/%.o) $(CXXSRC:%.cc=$(OBJ_DIR)/%.o) ... $(BINARY):: $(OBJS) $(ARCHIVES) @echo + LD $@ @$(LD) -o $@ $(OBJS) $(LDFLAGS) $(ARCHIVES) $(LIBS) $(OBJ_DIR)/%.o: %.cc @echo + CXX $\u0026lt; @mkdir -p $(dir $@) @$(CXX) $(CFLAGS) $(CXXFLAGS) -c -o $@ $\u0026lt; $(call call_fixdep, $(@:.o=.d), $@) 将变量和目标同名，再将这个目标作为依赖 是一种很方便且常见的用法，出现在目标和依赖中的变量会被展开为该变量的字符串。因此，执行命令 make run，会执行伪目标 run-env，而这个目标依赖 $(BINARY)， $(BINARY)有两个定义，其中非常重要的一个规则是 $(BINARY):: $(OBJS) $(ARCHIVES) ，它将$(OBJ) 中的.o 文件链接在一起，生成nume可执行文件。Makefile会根据$(OBJS)中文件的新旧或$(BINARY)是否存在来判断是否执行该规则。\nOBJ 变量将 SRCS 变量中的每一个 .c 文件名后缀替换成 .o ，再在该文件名前面添OBJ_DIR变量的字符串而来。 SRCS定义在 neme/Makefile 中：\n--------------------------------nemu/Makefile-------------------------------------- .... FILELIST_MK = $(shell find -L ./src -name \u0026#34;filelist.mk\u0026#34;) include $(FILELIST_MK) # Filter out directories and files in blacklist to obtain the final set of source files DIRS-BLACKLIST-y += $(DIRS-BLACKLIST) SRCS-BLACKLIST-y += $(SRCS-BLACKLIST) $(shell find -L $(DIRS-BLACKLIST-y) -name \u0026#34;*.c\u0026#34;) SRCS-y += $(shell find -L $(DIRS-y) -name \u0026#34;*.c\u0026#34;) SRCS = $(filter-out $(SRCS-BLACKLIST-y),$(SRCS-y)) .... SRCS 变量根据SRCS-BLACKLIST-y 筛选 SRCS-y 变量，而一些目录下的filelist.mk 会给变量SRCS-y 和DIR-y追加一些内容，例如 nemu/src/filelist.mk的SRCS-y 追加了 nemu-main.c ， DIRS-y 追加了三个目录。\n而nemu/Makefile会 inlcude 所有的 filelist.mk 文件。\n--------------------------------nemu/src/filelist.mk-------------------------------------- .. SRCS-y += src/nemu-main.c DIRS-y += src/cpu src/monitor src/utils ... 如果想在 src 中新建一个目录，并且将这里面的源文件参与链接，我们可以在 DIRS-y 添加一个新的目录，例如 src/new-dir。\n到现在为止，已经知道了nemu的makefile是如何收集以及收集哪些 .c 文件来编译，哪些 .o 来参与链接的了。\n"},{"id":24,"href":"/notes/docs/math/hidden/","title":"Hidden","section":"数学","content":" This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris # Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":25,"href":"/notes/docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":" Buttons # Buttons are styled links that can lead to local page or external link.\nExample # {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home Contribute "},{"id":26,"href":"/notes/docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":" Columns # Columns help organize shorter pieces of content horizontally for readability.\nExample # {{% columns [ratio=\u0026#34;1:1\u0026#34;] [class=\u0026#34;...\u0026#34;] %}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{% /columns %}} Left Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nMid Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\nRight Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nSettings size ratio for columns # {{% columns ratio=\u0026#34;1:2\u0026#34; %}} \u0026lt;!-- begin columns block --\u0026gt; ## x1 Column Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; ## x2 Column Lorem markdownum insigne... {{% /columns %}} x1 Column # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nx2 Column # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":27,"href":"/notes/docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":" Details # Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample # {{% details \u0026#34;Title\u0026#34; [open] %}} ## Markdown content Lorem markdownum insigne... {{% /details %}} {{% details title=\u0026#34;Title\u0026#34; open=true %}} ## Markdown content Lorem markdownum insigne... {{% /details %}} Title Markdown content # Lorem markdownum insigne\u0026hellip;\n"},{"id":28,"href":"/notes/docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":" Hints # Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{% hint [info|warning|danger] %}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{% /hint %}} Example # Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\nMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\nMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\n"},{"id":29,"href":"/notes/docs/shortcodes/mermaid/","title":"Mermaid","section":"Shortcodes","content":" Mermaid Chart # MermaidJS is library for generating svg charts and diagrams from text.\nOverride Mermaid initialization config\nTo override the initialization config for Mermaid, create a mermaid.json file in your assets folder!\nExample # {{\u0026lt; mermaid [class=\u0026#34;...\u0026#34;] \u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u0026gt; State2 note left of State2 : This is the note to the left. {{\u0026lt; /mermaid \u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u003e State2 note left of State2 : This is the note to the left. "},{"id":30,"href":"/notes/docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":" Section # Section renders pages in section as definition list, using title and description. Optional param summary can be used to show or hide page summary\nExample # {{\u0026lt; section [summary] \u0026gt;}} First Page First page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nSecond Page Second Page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n"},{"id":31,"href":"/notes/docs/shortcodes/section/first-page/","title":"First Page","section":"Section","content":" First page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":32,"href":"/notes/docs/shortcodes/section/second-page/","title":"Second Page","section":"Section","content":" Second Page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":33,"href":"/notes/docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":" Tabs # Tabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;id\u0026#34; \u0026gt;}} {{% tab \u0026#34;MacOS\u0026#34; %}} # MacOS Content {{% /tab %}} {{% tab \u0026#34;Linux\u0026#34; %}} # Linux Content {{% /tab %}} {{% tab \u0026#34;Windows\u0026#34; %}} # Windows Content {{% /tab %}} {{\u0026lt; /tabs \u0026gt;}} Example # MacOS MacOS # This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux Linux # This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows Windows # This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":34,"href":"/notes/docs/shortcodes/katex/","title":"KaTeX","section":"Shortcodes","content":" KaTeX # KaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample # {{\u0026lt; katex display=true \u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt; /katex \u0026gt;}} \\[ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi \\] Display Mode Example # Here is some inline example: \\(\\pi(x)\\) , rendered in the same line. And below is display example, having display: block \\[ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi \\] Text continues here.\n"}]