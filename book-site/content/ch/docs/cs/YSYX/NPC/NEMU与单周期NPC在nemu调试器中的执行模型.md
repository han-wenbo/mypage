# 0.引言

---

对于nemu和单周期的npc来说， `cpu.pc` 和 `void exec_once(Decode *s, vaddr_t pc)` 函数的语义是有一些区别的，因此本文记录一下他们之间的区别。

# 1. NEMU

---

在使用nemu原生的执行函数 `int isa_exec_once(Decode *s)` 时，假设 nemu 还未终止运行且不处于 `exec_once` 函数中时(也不处于被它调用的函数中)，`cpu.pc`指向是下一条要指向指令的地址。

阅读原生执行函数会发现，此时输入命令`si` ，可以抽象的将其行为理解成：

- **计算/获取处理器执行完这条指令应该所处于的状态所需的值，直接将这些值更新到处理器状态中(PC、寄存器、内存)。**

# 2. NPC

---

当使用 ` npc_exec()` 执行函数时，情况会有所不同，此时输入命令`si` ，nemu会：

- **将执行完cpu.pc 指向的指令应该所处于的状态所需的值写入处理器状态；**
- **获取/计算下一条指令要对处理器更新状态。**

这是因为 verilator 仿真器跑一周期需要如下操作：

```c++
// P1
top->clock=0;
top->eval();
// P2
top->clock=1;
top->eval();
// P3
```

假设处理器会顺序执行指令 I1，I2，I3，假设现在对 I1 执行这些函数。（更准确的说法需要等到介绍cpu.pc对npc的语义）

在执行完第二个 `eval()`后，会触发一个上升沿，这会立即更新处理器状态，更新到**执行完 I1 的状态**：PC (I2的PC)、寄存器、内存；然后这会引发仿真器对电路行为的一系列求值 (根据指令I2)，直到收敛为止，即通过新的状态计算下一次的状态，但是并不会更新到处理器的存储器件中。可以想象一下组合逻辑的某个输入更新了，整个电路状态都会根据这个输入而重新计算。

**注意读/写内存都是由DPI-C模拟的，，假设 I2 是一条 st 指令，在为 I1 执行第二次 `eval()` 的时候就会调用这访存的函数！因为访存模块是一个组合逻辑，而第二次执行`eval()`时， I2执行的所有状态已经计算出来了，只是还没写入到存储器件里，这当然包括写内存位置的 valid，wen 信号了。**

## 2. 关于cpu.pc的含义

对于原生 nemu 来说，当调用`int isa_exec_once(Decode *s)` 时，要执行执行的地址是由cpu.pc给出的。而在 npc 中，处理器有自己的保存pc的寄存器，而`cpu.pc`只是记录该寄存器中的值的一个变量。

假设，分别在 P1 P2 P3 位置读取程序计数器中的值，可以保证一下几点：

- 在执行一条指令前 ( 执行si命令前)，cpu.pc 的值与P1，P2位置读取程序计数器的的值相同，在执行完该指令后，cpu.pc和P3的值相同
