---
weight: 11
---

# 无符号数与补码加法硬件实现

---

本文的目的要描述下面这个命题：

{{% hint def%}} 使用传统的二进制数加法器就可以同时实现无符号数与补码的加法操作。{{% /hint %}}

## 1. 无符号数、补码与二进制数的区别

---

首先，要区分开无符号数编码、补码编码与二进制数的区别。对于形如“001001”的二进制数，它属于整数集合  {{< katex >}} \Z^+  {{< /katex >}} . 更细化一点，我们可以定义为 {{< katex >}} w  {{< /katex >}} 二进制数定义一个集合：

{{<katex display=true >}} 
N_w = \{b \in \N \mid  0 \le b \le  2^w -1 \}.

 {{< /katex >}}

而对于 {{< katex >}} w  {{< /katex >}} 位的一个编码串 (在CSAPP中被定义为位向量)，可以定义出它所属的集合：

{{<katex display=true >}} 
V_w = \left\{ [x_{w-1},...,x_0] \mid \forall i \in \{0,...,w-1\}(x_i \in {0,1}) \right\}.

 {{< /katex >}}

现在，可以很明显的看出来二进制数与所谓的向量之间的区别了。

现在给出另一个有用的定义，它包括所有长度的位向量：

{{<katex display=true >}} 
V = \bigcup_{k=1}^{\infty} V_k

 {{< /katex >}}.



## 2. 位向量转换为整数

为了更严谨的描述后续内容，对于{{< katex >}} w  {{< /katex >}}位向量 [1,0,0,1] , 有时候会需要将其转换为一个整数 1001 = 9；所以现在定一个具备该功能的函数：

{{<katex display=true >}} 
V2N: V \rightarrow \N  \\

V2N(\vec{v}_w) = \sum_{i=0}^{w-1}{v_i \cdot 2^{i}}，

 {{< /katex >}}

其中{{<katex>}} \vec{v}_w{{< /katex >}} 是一个 w 位的位向量，而 {{<katex>}} v_i{{< /katex >}} 是其分量。这是一个双射，所以存在反函数{{<katex>}} N2V :\N \rightarrow V{{< /katex >}} .

这与{{<katex>}} B2U_w {{< /katex >}}类似，但实际功能完全不同， 此处定义的函数可以以任意长度的位向量作为输入，并且输出是一个整数。而使用{{<katex>}} B2U_w {{< /katex >}}时， 只能以w位的位向量作为输出。除了数学性质上的区别外，定义这个函数也在于将计算机中的无符号数以及用于其编码的位向量和数学上的整数区分开来。

## 3. 无符号数加法与二进制数加法

对于 {{<katex>}} \vec{x}_w,\vec{y}_w {{< /katex >}},对其所编码的无符号数做无符号数加法操作，可以得到一个新的无符号数：

{{<katex display=true >}} 
u = B2U_w(\vec{x}_w) +_w^u B2U_w(\vec{y}_w) = 

\begin{cases}
B2U_w(\vec{x}_w) + B2U_w(\vec{y}_w) ,                   & x + (-_w^t y)  < 2^w\\
B2U_w(\vec{x}_w) + B2U_w(\vec{y}_w) - 2^w,       & 2^w \le B2U_w(\vec{x}_w) + B2U_w(\vec{y}_w) < 2^{w+1} 
\end{cases}

 {{< /katex >}}

考虑他们背后的位向量与二进制数之间的关系：

{{<katex display=true >}} 
V2N(\vec{x}_w) + V2N(\vec{y}_w) = V2N(U2B_w(u)) 

 {{< /katex >}}

或者，当无符号数加法溢出时：

{{<katex display=true >}} 
V2N(\vec{x}_w) + V2N(\vec{y}_w) = V2N(U2B_w(u)) + 10...00 

 {{< /katex >}}

可以看出，在不溢出的情况下，两个位向量所编码的无符号数之和，就是这两个位向量对应的二进制数之合，在溢出的情况下，这个二进制数比位向量多了一位1. 因此可以用二进制数加法器实现无符号数求和，只需简单的将进位丢弃，求和的结果n就是Vec(n).
