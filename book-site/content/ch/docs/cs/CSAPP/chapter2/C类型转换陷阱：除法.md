
# C类型转换陷阱：除法

---

在实现nemu表达式求值时，需要生成若干随机表达式来测试程序真确性，生成表达式后，自然也要计算其正确结果，然后nume再计算这个表达式的结果，与刚才计算的正确结果相比较。

在一开始时我错误的将 `eval()` 函数写成了具有 `int` 类型返回值， 而正确结果计算时候，每一个操作数的数据类型全是无符号数，因此导致了两个结果不相等。尽管只需要将 `eval(...)`返回值修改成无符号数就可以让两次求值结果相同，但是还是值得探究一下其原因，我将这个问题在本文中简化并且抽象出来了。

考虑如下代码中, `a`和`b` 的值是什么？

```c++
#include <stdio.h>

int main() {

    int a = -5 / -6;
    unsigned int b = (unsigned int)-5 / (unsigned int)-6;
    printf("a: %d, b: %u\n", a, b);
    return 0;
}                  
```

在`int` 和 `unsigned int` 都是32位的情况下，该程序的输出如下

```
a: 0, b: 1
```

`a` 的值很明显，因为 `-5/-6 = 0.83333...` ，根据c语言整数除法，只会保留 `0` 作为结果。 现在考虑 `b` 的值， 将 `-5` 转化为 32 位无符号数应为 `4294967291` ,而 `-6` 为 `4294967290`， 所以 `b = 4294967291 / 4294967290 = 1.000000232831` ，c 语言为其保留整数部分，所以 `b` 的值就是 `1` 。

# 后续工作（1）：一个需要证明的命题

---



因此是否可以断言 `给定两个数，分别做整数除法和无符号数除法，其结果位向量不一定相同`？ 那对于乘法呢？

# 后续工作（2）：学习C语言中对表达式求值时的数据类型转换

---

例如一个32位无符号数除以16位有符号数，该如何计算？答案在https://en.cppreference.com/w/c/language/conversion.html里。



